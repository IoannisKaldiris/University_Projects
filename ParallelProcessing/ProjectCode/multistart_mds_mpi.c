#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <mpi.h>

#define MAXVARS (250) /* max # of variables	     */
#define EPSMIN (1E-6) /* ending value of stepsize  */

/* prototype of local optimization routine, code available in torczon.c */
extern void mds(double *startpoint, double *endpoint, int n, double *val, double eps, int maxfevals, int maxiter,
				double mu, double theta, double delta, int *ni, int *nf, double *xl, double *xr, int *term);

/* global variables */
unsigned long funevals = 0;

/* Rosenbrock classic parabolic valley ("banana") function */
double f(double *x, int n)
{
	double fv;
	int i;
	funevals++;

	fv = 0.0;
	for (i = 0; i < n - 1; i++) /* rosenbrock */
		fv = fv + 100.0 * pow((x[i + 1] - x[i] * x[i]), 2) + pow((x[i] - 1.0), 2);
	usleep(1); /* do not remove, introduces some artificial work */

	return fv;
}

double get_wtime(void)
{
	struct timeval t;

	gettimeofday(&t, NULL);

	return (double)t.tv_sec + (double)t.tv_usec * 1.0e-6;
}

int main(int argc, char *argv[])
{
	int rank, size; 

	// initialize the MPI Environment
	MPI_Init(&argc, &argv);

	// get the size and rank of the process
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	int nvars, ntrials;	

	// Only one process will define the looping parameter
	if(rank==0){
		/* problem parameters */
		nvars = 4;						   /* number of variables (problem dimension) */
		ntrials = 64;					   /* number of trials */
	}

	// Make nvars and ntrial available to all the processes
	MPI_Bcast(&nvars, 1, MPI_INT, 0, MPI_COMM_WORLD);
	MPI_Bcast(&ntrials, 1, MPI_INT, 0, MPI_COMM_WORLD);

	double lower[MAXVARS], upper[MAXVARS]; /* lower and upper bounds */
	/* mds parameters */
	double eps = EPSMIN;
	int maxfevals = 10000;
	int maxiter = 10000;
	double mu = 1.0;
	double theta = 0.25;
	double delta = 0.25;

	double startpt[MAXVARS], endpt[MAXVARS]; /* initial and final point of mds */
	double fx;								 /* function value at the final point of mds */
	int nt, nf;								 /* number of iterations and function evaluations used by mds */

	/* information about the best point found by multistart */
	double best_pt[MAXVARS];
	double best_fx = 1e10;
	int best_trial = -1;
	int best_nt = -1;
	int best_nf = -1;

	/* local variables */
	int trial, i;
	double t0, t1;

	/* initialization of lower and upper bounds of search space */
	for (i = 0; i < MAXVARS; i++)
		lower[i] = -2.0; /* lower bound: -2.0 */
	for (i = 0; i < MAXVARS; i++)
		upper[i] = +2.0; /* upper bound: +2.0 */

	t0 = get_wtime();

	// dividing the work among the processes
	int start= rank*(ntrials/size);
	int end = (rank+1)*(ntrials/size);
	if(rank==size-1){
		end = ntrials;
	}

	for (trial = start; trial < end; trial++)
	{
		/* random starting point for mds */
		srand48(trial);

		/* starting guess for rosenbrock test function, search space in [-2, 2) */
		// this part is important, we want to generate the same number as generated by the serial program
		
		for (i = 0; i < nvars; i++)
		{
			startpt[i] = lower[i] + (upper[i] - lower[i]) * drand48();
		}
		int term = -1;
		mds(startpt, endpt, nvars, &fx, eps, maxfevals, maxiter, mu, theta, delta,
			&nt, &nf, lower, upper, &term);

		#if DEBUG
			printf("\n\n\nMDS %d USED %d ITERATIONS AND %d FUNCTION CALLS, AND RETURNED\n", trial, nt, nf);
			for (i = 0; i < nvars; i++)
				printf("x[%3d] = %15.7le \n", i, endpt[i]);

			printf("f(x) = %15.7le\n", fx);
		#endif

		/* keep the best solution */
		if (fx < best_fx)
		{
			// We will update the best solution based on the best_fx value
			// the recheck ensures that the entered thread has the best result
			best_trial = trial;
			best_nt = nt;
			best_nf = nf;
			best_fx = fx;
			for (i = 0; i < nvars; i++)
				best_pt[i] = endpt[i];
		}
	}
	
	// We will reduce the best_fx value to the root process
	unsigned long reduced_funevals;
	MPI_Reduce(&funevals, &reduced_funevals, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);

	// we first find the best_fx value, then only that process value will be considered
	// for the best_fx value
	double reduced_best_fx;
	// Make the best function value out of all the process to the root process
	MPI_Allreduce(&best_fx, &reduced_best_fx, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

	// send the rank of the reduced_best_fx to the root process
	// Only the process with the best_fx value will send the data to the root process
	if(reduced_best_fx==best_fx){
		// send the best trial no 
		MPI_Send(&best_trial, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
		// send the best_nt value
		MPI_Send(&best_nt, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
		// send the best_nf value
		MPI_Send(&best_nf, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
		// send the best_pt value
		MPI_Send(best_pt, nvars, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
	}


	if(rank==0){
		// recieve the best trial no
		MPI_Recv(&best_trial, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
		// recieve the best_nt value
		MPI_Recv(&best_nt, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
		// recieve the best_nf value
		MPI_Recv(&best_nf, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
		// recieve the best_pt value
		MPI_Recv(best_pt, nvars, MPI_DOUBLE, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
		// print the results
		t1 = get_wtime();
		printf("\n\nFINAL RESULTS:\n");
		printf("Elapsed time = %.3lf s\n", t1 - t0);
		printf("Total number of trials = %d\n", ntrials);
		printf("Total number of function evaluations = %ld\n", reduced_funevals);
		printf("Best result at trial %d used %d iterations, %d function calls and returned\n", best_trial, best_nt, best_nf);
		for (i = 0; i < nvars; i++)
		{
			printf("x[%3d] = %15.7le \n", i, best_pt[i]);
		}
		printf("f(x) = %15.7le\n", reduced_best_fx);
	}
	
	MPI_Finalize();
	return 0; 
}
